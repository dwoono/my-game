<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Crowd Runner 3D</title>
    <style>
        body { margin: 0; background: #87ceeb; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        #game-container { width: 800px; height: 440px; background: #87ceeb; position: relative; overflow: hidden; font-family: sans-serif; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #main-menu { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; }
        .btn { padding: 10px 20px; cursor: pointer; border: none; font-weight: bold; color: white; transition: 0.2s; }
        .btn-easy { background: #4CAF50; }
        .btn-normal { background: #FF9800; }
        .btn-hard { background: #f44336; }
        .btn:hover { opacity: 0.8; transform: scale(1.1); }
        #top-bar { width: 100%; height: 40px; background: rgba(0,0,0,0.5); display: none; justify-content: space-around; align-items: center; color: white; z-index: 10; position: absolute; }
        #side-ui { position: absolute; top: 50px; left: 10px; z-index: 100; display: none; flex-direction: column; gap: 8px; }
        #msg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 150; color: white; }
        #text-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="main-menu">
        <h1 style="color: #ffd700; margin-bottom: 20px;">CROWD RUNNER 3D</h1>
        <div style="display: flex; gap: 15px;">
            <button class="btn btn-easy" onclick="startGame(1)">Easy</button>
            <button class="btn btn-normal" onclick="startGame(2)">Normal</button>
            <button class="btn btn-hard" onclick="startGame(3)">Hard</button>
        </div>
    </div>

    <div id="top-bar">
        <div><b>STAGE:</b> <span id="ui-stage">1</span></div>
        <div><b>COUNT:</b> <span id="count">10</span></div>
        <div><b>BOSS HP:</b> <span id="boss-hp" style="color: #ff4444;">-</span></div>
    </div>

    <div id="side-ui">
        <button id="btn-pause" onclick="togglePause()">일시정지</button>
        <button onclick="location.reload()" style="background: #555; color: white;">재시작</button>
    </div>

    <div id="canvas-holder"></div>
    <div id="msg-overlay">
        <h2 id="msg-text" style="font-size: 40px; margin-bottom: 20px;"></h2>
        <button onclick="location.reload()" style="padding: 10px 30px; cursor: pointer; font-size: 20px;">메인으로</button>
    </div>
    <div id="text-layer"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer, playerGroup, boss;
    let count = 10, bossHP = 0, isPaused = false, currentStage = 1;
    let gates = [], enemies = [], bullets = [], subCharacters = [];
    let gamePhase = 'menu', lastAutoShot = 0, aniId;
    let moveLeft = false, moveRight = false;
    const worldPos = new THREE.Vector3();

    // 이미지 로딩 (깃허브 폴더에 이미지 파일이 있어야 함)
    const loader = new THREE.TextureLoader();
    const pTex = loader.load("image_3.png"); 
    const bTex = loader.load("image_4.png");

    const stageConfigs = {
        1: { speed: 0.4, bossHP: 40000, enemyHP: 1000 },
        2: { speed: 0.5, bossHP: 120000, enemyHP: 2500 },
        3: { speed: 0.65, bossHP: 300000, enemyHP: 6000 }
    };

    function startGame(stage) {
        currentStage = stage;
        gamePhase = 'running';
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('top-bar').style.display = 'flex';
        document.getElementById('side-ui').style.display = 'flex';
        document.getElementById('ui-stage').innerText = stage;
        initGame();
    }

    function initGame() {
        const holder = document.getElementById('canvas-holder');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        camera = new THREE.PerspectiveCamera(75, 800 / 440, 0.1, 2000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(800, 440);
        holder.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(10, 20, 10);
        scene.add(sun);

        const river = new THREE.Mesh(new THREE.PlaneGeometry(200, 5000), new THREE.MeshPhongMaterial({color: 0x0077be}));
        river.rotation.x = -Math.PI / 2;
        river.position.y = -0.1;
        scene.add(river);

        const bridge = new THREE.Mesh(new THREE.PlaneGeometry(20, 5000), new THREE.MeshPhongMaterial({color: 0x8b4513}));
        bridge.rotation.x = -Math.PI / 2;
        scene.add(bridge);

        playerGroup = new THREE.Group();
        scene.add(playerGroup);

        count = 10;
        bossHP = stageConfigs[currentStage].bossHP;
        spawnBoss();
        spawnMap();
        updateCrowd();
        camera.position.set(0, 12, 18);
        animate();
    }

    function spawnBoss() {
        boss = new THREE.Mesh(new THREE.BoxGeometry(15, 15, 0.2), new THREE.MeshPhongMaterial({ map: bTex, transparent: true }));
        boss.position.set(0, 7.5, -1300);
        boss.userData = { type: 'boss' };
        scene.add(boss);
        document.getElementById('boss-hp').innerText = bossHP;
    }

    function spawnMap() {
        const conf = stageConfigs[currentStage];
        for(let i=1; i<=65; i++) {
            let zPos = -i * 25;
            if(Math.random() < 0.4) {
                let val = i * 12;
                const g = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 0.5), new THREE.MeshPhongMaterial({color: 0x00ff00, transparent: true, opacity: 0.7}));
                g.position.set(Math.random() > 0.5 ? -4 : 4, 2, zPos);
                g.userData = { type: 'gate', gateType: 'add', value: val };
                scene.add(g); gates.push(g);
            }
            if(i % 5 === 0) {
                const e = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.1), new THREE.MeshPhongMaterial({map: bTex, color: 0xff4444, transparent: true}));
                e.position.set((Math.random()-0.5)*14, 2, zPos - 12);
                e.userData = { type: 'enemy', hp: i * conf.enemyHP };
                scene.add(e); enemies.push(e);
            }
        }
    }

    function updateCrowd() {
        subCharacters.forEach(c => playerGroup.remove(c));
        subCharacters = [];
        let visualCount = Math.min(count, 40);
        const charMat = new THREE.MeshPhongMaterial({ map: pTex, transparent: true });
        for(let i=0; i<visualCount; i++) {
            const char = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.1), charMat);
            let phi = i * Math.PI * (3 - Math.sqrt(5)), radius = 0.7 * Math.sqrt(i);
            char.position.set(Math.cos(phi) * radius, 0.9, Math.sin(phi) * radius);
            playerGroup.add(char); subCharacters.push(char);
        }
        document.getElementById('count').innerText = count;
    }

    function togglePause() {
        isPaused = !isPaused;
        document.getElementById('btn-pause').innerText = isPaused ? "이어하기" : "일시정지";
    }

    function shoot() {
        const bCount = Math.min(Math.ceil(count / 50), 12);
        const dmg = count / bCount;
        for(let i=0; i<bCount; i++) {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color: 0xffff00}));
            b.position.set(playerGroup.position.x + (i - (bCount-1)/2) * 0.8, 1.5, playerGroup.position.z - 2);
            b.userData = { damage: dmg };
            scene.add(b); bullets.push(b);
        }
    }

    function gameOver(win) {
        gamePhase = 'over';
        document.getElementById('msg-overlay').style.display = 'flex';
        document.getElementById('msg-text').innerText = win ? "STAGE CLEAR!" : "GAME OVER";
        document.getElementById('msg-text').style.color = win ? "#00ff00" : "#ff0000";
    }

    function animate(time) {
        if (gamePhase !== 'running' || isPaused) { aniId = requestAnimationFrame(animate); return; }
        aniId = requestAnimationFrame(animate);

        playerGroup.position.z -= stageConfigs[currentStage].speed;
        if(moveLeft && playerGroup.position.x > -8.5) playerGroup.position.x -= 0.4;
        if(moveRight && playerGroup.position.x < 8.5) playerGroup.position.x += 0.4;

        if(time - lastAutoShot > 200) { shoot(); lastAutoShot = time; }

        camera.position.z = playerGroup.position.z + 18;
        camera.position.x = playerGroup.position.x * 0.5;
        camera.lookAt(playerGroup.position.x, 2, playerGroup.position.z - 15);

        bullets.forEach((b, bi) => {
            b.position.z -= 2.5;
            if(b.position.z < playerGroup.position.z - 120) { scene.remove(b); bullets.splice(bi, 1); return; }
            
            gates.forEach(g => {
                if(b && b.position.distanceTo(g.position) < 3.5) {
                    g.userData.value += Math.max(1, Math.floor(count * 0.05));
                    scene.remove(b); bullets.splice(bi, 1);
                }
            });

            enemies.forEach((e, ei) => {
                if(b && b.position.distanceTo(e.position) < 3.5) {
                    e.userData.hp -= b.userData.damage;
                    scene.remove(b); bullets.splice(bi, 1);
                    if(e.userData.hp <= 0) { scene.remove(e); enemies.splice(ei, 1); }
                }
            });

            if(b && b.position.distanceTo(boss.position) < 8) {
                bossHP -= b.userData.damage;
                document.getElementById('boss-hp').innerText = Math.max(0, Math.floor(bossHP));
                scene.remove(b); bullets.splice(bi, 1);
                if(bossHP <= 0) gameOver(true);
            }
        });

        enemies.forEach((e, ei) => {
            let hit = false;
            for(let char of subCharacters) {
                char.getWorldPosition(worldPos);
                if(worldPos.distanceTo(e.position) < 2.5) { hit = true; break; }
            }
            if(hit) {
                count = Math.max(1, Math.floor(count * 0.4));
                updateCrowd(); scene.remove(e); enemies.splice(ei, 1);
            }
        });

        if(playerGroup.position.z < boss.position.z + 5 && bossHP > 0) gameOver(false);

        gates.forEach((g, i) => {
            if(playerGroup.position.distanceTo(g.position) < 4.5) {
                count += g.userData.value;
                updateCrowd(); scene.remove(g); gates.splice(i, 1);
            }
        });

        updateUI();
        renderer.render(scene, camera);
    }

    function updateUI() {
        const layer = document.getElementById('text-layer');
        layer.innerHTML = '';
        [...gates, ...enemies, boss].forEach(obj => {
            if(!obj || obj.position.z > playerGroup.position.z + 10) return;
            const vector = obj.position.clone().project(camera);
            const x = (vector.x * 0.5 + 0.5) * 800, y = (vector.y * -0.5 + 0.5) * 440;
            const label = document.createElement('div');
            label.style = "position:absolute; left:"+x+"px; top:"+y+"px; color:white; font-weight:bold; transform:translate(-50%, -100%); text-shadow:1px 1px 2px black;";
            if(obj.userData.type==='gate') label.innerText = '+' + obj.userData.value;
            else if(obj.userData.type==='enemy') label.innerText = 'HP:' + Math.floor(obj.userData.hp);
            else if(obj.userData.type==='boss') label.innerText = 'BOSS';
            layer.appendChild(label);
        });
    }

    window.onkeydown = (e) => { 
        if(e.key === 'a' || e.key === 'ArrowLeft') moveLeft = true;
        if(e.key === 'd' || e.key === 'ArrowRight') moveRight = true;
    };
    window.onkeyup = (e) => { 
        if(e.key === 'a' || e.key === 'ArrowLeft') moveLeft = false;
        if(e.key === 'd' || e.key === 'ArrowRight') moveRight = false;
    };
</script>

</body>
</html>